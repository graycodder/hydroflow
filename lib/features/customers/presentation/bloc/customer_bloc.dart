import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:hydroflow/features/customers/domain/entities/customer.dart';
import 'package:hydroflow/features/customers/domain/usecases/add_customer_usecase.dart';
import 'package:hydroflow/features/customers/domain/usecases/get_customers_usecase.dart';
import 'package:hydroflow/features/customers/domain/usecases/update_customer_status_usecase.dart';
import 'package:hydroflow/features/customers/domain/usecases/update_customer_status_usecase.dart';
import 'package:hydroflow/features/customers/domain/usecases/update_customer_usecase.dart';
import 'package:hydroflow/features/customers/domain/usecases/settle_customer_usecase.dart';
import 'package:hydroflow/features/customers/presentation/bloc/customer_event.dart';
import 'package:hydroflow/features/customers/presentation/bloc/customer_state.dart';

class CustomerBloc extends Bloc<CustomerEvent, CustomerState> {
  final GetCustomersUseCase getCustomers;
  final AddCustomerUseCase addCustomer;
  final UpdateCustomerStatusUseCase updateCustomerStatus;
  final UpdateCustomerUseCase updateCustomer;
  final SettleCustomerUseCase settleCustomer;

  CustomerBloc({
    required this.getCustomers,
    required this.addCustomer,
    required this.updateCustomerStatus,
    required this.updateCustomer,
    required this.settleCustomer,
  }) : super(const CustomerState()) {
    on<LoadCustomers>(_onLoadCustomers);

    on<AddCustomer>(_onAddCustomer);
    on<SearchCustomers>(_onSearchCustomers);
    on<UpdateCustomerStatus>(_onUpdateCustomerStatus);
    on<UpdateCustomer>(_onUpdateCustomer);
    on<SettleCustomer>(_onSettleCustomer);
  }

  Future<void> _onLoadCustomers(
    LoadCustomers event,
    Emitter<CustomerState> emit,
  ) async {
    emit(state.copyWith(status: CustomerStatus.loading));
    
    await emit.forEach<List<Customer>>(
      getCustomers(event.salesmanId),
      onData: (customers) {
        final activeCount = customers.where((c) => c.status == 'Active').length;
        final inactiveCount = customers.length - activeCount;

        // Apply search filter if query exists, else show all
        // We need to persist the filter if it exists. 
        // Note: emit.forEach replaces state. logic needs to be careful.
        // Simplified: When data updates, we reset search for now OR re-apply filtering logic if we stored query.
        // Ideally we should store query in state. We don't have it in state explicitly as a field query string.
        // Let's just return full list and filtered list as same, unless we want to keep search active.
        // Given complexity, let's just show full list on update.
        
        return state.copyWith(
          status: CustomerStatus.success,
          customers: customers,
          filteredCustomers: customers, // Reset filter on external update for simplicity
          totalCustomers: customers.length,
          activeCustomers: activeCount,
          inactiveCustomers: inactiveCount,
        );
      },
      onError: (error, stackTrace) => state.copyWith(
        status: CustomerStatus.failure,
        errorMessage: 'Failed to load customers: $error',
      ),
    );
  }

  Future<void> _onAddCustomer(
    AddCustomer event,
    Emitter<CustomerState> emit,
  ) async {
    emit(state.copyWith(status: CustomerStatus.loading));
    try {
      final newCustomer = Customer(
        id: '', // Generated by Repo/DB
        salesmanId: event.salesmanId,
        name: event.name,
        phone: event.phone,
        address: event.address,
        status: 'Active',
        securityDeposit: event.securityDeposit,
      );

      await addCustomer(newCustomer);
      
      // Reload customers after adding
      // add(LoadCustomers(event.salesmanId)); // Stream handles update automatically
    } catch (e) {
      emit(state.copyWith(
        status: CustomerStatus.failure,
        errorMessage: 'Failed to add customer: $e',
      ));
    }
  }

  void _onSearchCustomers(
    SearchCustomers event,
    Emitter<CustomerState> emit,
  ) {
    if (event.query.isEmpty) {
      emit(state.copyWith(filteredCustomers: state.customers));
    } else {
      final queryLower = event.query.toLowerCase();
      final filtered = state.customers.where((customer) {
        return customer.name.toLowerCase().contains(queryLower) ||
               customer.phone.contains(queryLower);
      }).toList();
      emit(state.copyWith(filteredCustomers: filtered));
    }
  }

  Future<void> _onUpdateCustomerStatus(
    UpdateCustomerStatus event,
    Emitter<CustomerState> emit,
  ) async {
    // Optimistic update could be done here, but for simplicity/reliability reusing load
    try {
      await updateCustomerStatus(event.customerId, event.status, event.salesmanId);
      // add(LoadCustomers(event.salesmanId)); // Stream handles update automatically
    } catch (e) {
       emit(state.copyWith(
        status: CustomerStatus.failure,
        errorMessage: 'Failed to update status: $e',
      ));
    }
  }

  Future<void> _onUpdateCustomer(
    UpdateCustomer event,
    Emitter<CustomerState> emit,
  ) async {
    try {
      await updateCustomer(event.customer);
    } catch (e) {
      emit(state.copyWith(
        status: CustomerStatus.failure,
        errorMessage: 'Failed to update customer: $e',
      ));
    }
  }

  Future<void> _onSettleCustomer(
    SettleCustomer event,
    Emitter<CustomerState> emit,
  ) async {
    try {
      await settleCustomer(event.customer);
      // Wait a bit to ensure propagation or just rely on stream update
      // Optionally emit success message or refresh
    } catch (e) {
       emit(state.copyWith(
        status: CustomerStatus.failure,
        errorMessage: 'Failed to settle customer: $e',
      ));
    }
  }
}
